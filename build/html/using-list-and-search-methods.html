<h1>List and search methods</h1>
<p>The Bonita BPM Engine APIs contain several list and search methods. This page explains the difference between list and search, and explains how to configure word-based search.</p>
<p>The following example shows how to use a list method to see the archived activity instances:</p>
<pre><code class="language-java">List&lt;ArchivedActivityInstance&gt; archivedActivityInstances = 
    TenantAPIAccessor.getProcessAPI(session).getArchivedActivityInstances(instance.getId(), 0, 100, ActivityInstanceCriterion.NAME_ASC);
</code></pre>
<p>The following example shows how to use a search method to see the archived activity instances.</p>
<pre><code class="language-java">SearchOptionsBuilder searchBuilder = new SearchOptionsBuilder(0, 100);
searchBuilder.sort(ArchivedActivityInstanceSearchDescriptor.NAME, Order.ASC);
SearchResult&lt;ArchivedActivityInstance&gt; archActivitResult = TenantAPIAccessor.getProcessAPI(session).searchArchivedActivities(searchBuilder.done());
</code></pre>
<p>These two examples above return identical information. Both list and search can be used to return a specified number of results, sorted according to a specified criterion.</p>
<p>The advantage of using list is that it is a single query, so has better performance. It is also simpler to code.</p>
<p>The advantage of using search is that you can specify filters to get a more precise set of results, which can be more efficient. Several filters can be added. By default, an implicit AND clause is added when several filters are added. If the need is different,
you can have an OR clause, of more complex clauses. See <a href="http://documentation.bonitasoft.com/javadoc/api/7.1/org/bonitasoft/engine/search/SearchOptionsBuilder.html">SearchOptionsBuilder methods</a> for filtering that matches your needs.<br>
The following example is a more precise search for archived activity instances, using a filter:</p>
<pre><code class="language-java">SearchOptionsBuilder searchBuilder = new SearchOptionsBuilder(0, 100);
// implicit AND clause between the following two filters:
searchBuilder.filter(ArchivedActivityInstanceSearchDescriptor.ROOT_PROCESS_INSTANCE_ID, processInstance.getId());
searchBuilder.filter(ArchivedActivityInstanceSearchDescriptor.ASSIGNEE_ID, myUser.getId());
searchBuilder.sort(ArchivedActivityInstanceSearchDescriptor.NAME, Order.ASC);
SearchResult&lt;ArchivedActivityInstance&gt; archActivitResult = TenantAPIAccessor.getProcessAPI(session).searchArchivedActivities(searchBuilder.done());
</code></pre>
<p>Below is another example of a more complex search filtering.</p>
<pre><code class="language-java">SearchOptionsBuilder sob = new SearchOptionsBuilder(0, 10);
sob.filter(HumanTaskInstanceSearchDescriptor.PROCESS_INSTANCE_ID, myProcessInstance.getId());
sob.or();
sob.differentFrom&lt;/b&gt;(HumanTaskInstanceSearchDescriptor.ASSIGNEE_ID, myUser.getId());
</code></pre>
<h2>Word-based search</h2>
<p>By default, search uses a &quot;starts by&quot; algorithm for searching, and finds matches where the search string occurs at the start of a phrase.
If word-based search is enabled, you can search for a string that is preceded by white space or is at the start of the phrase.
For example:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Phrase in database</th>
<th style="text-align:left">Search string</th>
<th style="text-align:left">Matches with &quot;starts with&quot;</th>
<th style="text-align:left">Matches with word-based search</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Hello Charles</td>
<td style="text-align:left">charles</td>
<td style="text-align:left">no</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Hello Charles</td>
<td style="text-align:left">he</td>
<td style="text-align:left">yes</td>
<td style="text-align:left">yes</td>
</tr>
<tr>
<td style="text-align:left">Hello Charles</td>
<td style="text-align:left">carl</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
</tr>
<tr>
<td style="text-align:left">Hello_Charles</td>
<td style="text-align:left">ch</td>
<td style="text-align:left">no</td>
<td style="text-align:left">no</td>
</tr>
</tbody>
</table>
<p>Using word-based search has an impact on performance, so by default it is disabled. You can enable it for the platform or for a tenant. If you enable it, you can exclude any objects for which it is not useful.</p>
<p>To configure word-based search, edit <em><code>bonita_home</code></em><code>bonita-platform-community-custom.properties</code> and make the following changes:</p>
<ol>
<li>Change the value of <code>bonita.platform.persistence.platform.enableWordSearch</code> (for the platform) or <code>bonita.platform.persistence.tenant.enableWordSearch</code> (for a tenant) to <code>true</code> in the following line:<pre><code class="language-xml">&lt;constructor-arg name=&quot;enableWordSearch&quot; value=&quot;false&quot; /&gt;
</code></pre>
</li>
<li>For each object you be excluded from word-based search, add a mapping to the <code>wordSearchExclusionMappings</code> set. Each mapping has the following form:<pre><code class="language-xml">&lt;value&gt;org.bonitasoft.engine.identity.model.SUser&lt;/value&gt;
</code></pre>
</li>
</ol>
<p>When you restart the Engine, these settings are applied and word-based search comes into operation.</p>
