= Execution sequence of actions, states, and transactions
:description: Understand the sequence of actions performed when a process instance is created and when a task is performed by a user and know the flow nodes states
:page-aliases: engine-flow-node-states.adoc

{description}

[NOTE]
====

In the sequences described in this page, some of the actions apply only to *Teamwork*, *Efficiency*, or *Performance* editions,
and are marked "Subscription only". +
For the *Community* edition, these actions are not relevant, but the order of the other actions is the same.
====

== Flow node

A flow node is a generic name to talk about BPM elements: activities, events, gateways, connectors.

== Flow node states and transactions

A flow node is defined by a set of states. +
Each state has a specific behaviour and its execution is wrapped into an https://en.wikipedia.org/wiki/ACID[ACID] transaction. +

A state is either _stable_, _terminal_, or _unstable_:

* Stable: the flow node is not yet finished, but paused as it waits for input. A stable state is waiting for either:

 ** A Human interaction to change (Ready/Failed).
 ** A BPMN event (Waiting).
  *** intermediateCatch
  *** receive
  *** boundary
 ** Children to finish (Execution/Cancelling/Aborting/CompletingSubTaskOfManualTask....).
  *** Loop
  *** MultiInstance
  *** CallActivity...

  A flow node will stay in a stable state until the event it is waiting for occurs. No work is generated in the meantime. The transaction is committed. +
  To learn more about works, go xref:works-index.adoc[the dedicated documentation page].

* Terminal: A terminal state is a stable state. It is the last state reached by a flow node. +
  Executing the flow node in terminal state will archive the flow node, delete it and trigger the asynchronous execution of the following elements of the process. +
  You can not "come back" from a terminal step. The one exception is the transition *COMPLETED* \-> *FAILED*.

* Unstable: All other states are unstable. +
  When a flow node reaches an unstable state, a work will be generated to change to another state. +
  Examples: ExecutingAutomaticActivity, InitializingAndExecutingFlownode, EndingIntermediateCatchEvent...

=== Special States: the non-executing states

To determine the next state, we execute the `shouldExecuteState()` code. If this method returns false, the `execute()` method is not run. +
We then execute the `shouldExecuteState()` code of the next state (determined by the state transition manager), etc. until the method returns true.

=== Summary of state types

* *INITIALIZING*: indicates that an activity is being initialized.
* *READY*: indicates that a user or manual task has been initialized but is not yet being executed.
* *WAITING*: indicates that a RECEIVE_TASK, BOUNDARY_EVENT or INTERMEDIATE_CATCH_EVENT activity is waiting for some external trigger.
* *EXECUTING*: indicates that an activity is being executed.
* *FAILED*: indicates that a task has failed because of a problem in execution, for example because of an exception that was not anticipated, a connector that fails, or bad expression design.
* *SKIPPED*: indicates that a task that failed because of connector execution failure is being skipped instead of re-executed. Skipping a task skips the execution of any connectors not already executed and proceeds to task completion.
* *CANCELLED*: indicates that an activity is cancelled by a user.
* *ABORTING*: indicates that an activity is cancelled by the system. For example, an interrupting event sub-process can trigger ABORTS for all other active paths.
* *COMPLETED*: indicates an activity that is complete.
* *ERROR*: not currently used.

=== Transitioning from state to state

Executing a state of a flow node is running the code of the `execute()` method on the *current* state, and then moving the flow node to the next state (determined by the transitions). +
When executing the state of a flow node, a return code indicates if the execution of the state is finished, meaning we can move on to the next state, or not finished, meaning we stay on the same state, some background task will trigger the move to the next state later (Eg. connector execution).

If the state is finished, the State Machine determines the next state: +

. Each flow node type has an ordered list of states. +
. We take the next state in the list, and ask the state to determine whether we should execute the state or not. +

   * If not, the next state is *SKIPPED* and the second next state is checked the same way, until a state determines it should be executed. +
   * If so, the next state is *EXECUTED*, in another background task (if terminal or not stable).

== Specific examples of states transitions 

=== At process _instantiation_ through an instantiation form

. An application display the process instantiation form to the user
. The user enters data in the form
. The button of the form holding the *Start process* action in the UI Designer sends a POST request with the form data to start the process
. The submitted data are validated against the *process instantiation contract*
. If the contract is valid, the process instance is created and input values are persisted in the database
. Process data instances are created and initialized in the order of declaration using:

   * An *operation* declared on the process that saves its value to the process data
   * The *initial value expression* if no operation is declared
   * *null* if no expression or operation is defined

. Bonita Engine creates and initializes business data
. Bonita Engine creates and initializes search keys
. Bonita Engine initializes process instance Documents with default value coming from the definition or with submitted files
. Operations (that does not initialize data) are executed. Operations at process instantiation level can either come from calling process instances (for processes stared by call-activities)
. Bonita Engine instantiates and executes the "on enter" connectors (evaluate input expression, execute, evaluate output operation). Connectors are executed in the order of declaration:

   * *Community*: Execution duration is not limited. If the connector never finishes, the process instantiation will never finish +
   * *Subscription*: Execution duration of a connector is limited to a maximum of 5 minutes by default. This timeout value can be changed by configuration. Above this limit,
the connector execution is aborted and the process instantiation is considered failed.

. The process is instantiated, the API call finishes and the Engine executes the process flow asynchronously

=== At user task _initialization_

During user task initialization, Bonita Engine:

. Initializes task variables with their default values
. Executes actor filters and then potentially assigns the task to a user
. Launches the "on enter" connectors
. Evaluates the task dynamic name and description. This will be evaluated only once

The user task is now in *READY* state and is waiting for a user to perform and submit it.

=== At user task _execution_

. An application displays the form to the user
. The user enters data in the form
. The button of the form holding the *Submit task* action in the *UI Designer* sends a POST request with the form data to start the step
. The submitted data are validated against the *step contract*
. If the contract is valid input values are persisted in database and the execution continues asynchronously. Otherwise an exception is thrown and the step stays in the same state
. Bonita Engine executes the Operations defined for the step
. Bonita Engine launches the "on finish" connectors
. Bonita Engine processes the Description after step completion
. The task is complete.

=== At other activities _execution_

. Get the current state of the activity
. Execute the state's behavior
. Find the next state of the flow node and set it as the current state
 .. If the state is stable, the transaction is committed, and the API call is returned
 .. If the state is terminal, the transaction is committed, Bonita Engine triggers the asynchronous execution of the followings elements of the process and the API call is returned
 .. If the state is neither stable nor terminal, the transition to the next state is scheduled asynchronously

=== Abort/Cancel procedure

Aborting is the action of changing the flow of transitions from the normal flow to the *ABORTING* sequence of states. It is triggered by the Bonita Engine itself. +
Cancelling is the same notion, but triggered by a human interaction. The flow is the *CANCELLING* sequence of states.

Aborting / cancelling a flow node is only setting its flag *stateCategory* to *ABORTING* / *CANCELLING* + registering works to execute the flow nodes.

==== Aborting a flow node

When the execution of a flow node sees that the state category of the flow node is *not the same* as the state category of the state (determined by the State Machine), then the current state is *not* executed (to the contrary of a normal case).- +
Then the next state is the first state of the aborting flow sequence for that type of flow node. +
Then the state is executed in a background task, as usual, and then follows the aborting flow sequence of states, until it reaches the last state in that sequence.

==== Cancelling a flow node

Cancelling a flow node is exactly the same as aborting a flow node, but the flow sequence of states is the *CANCELLING* sequence.
